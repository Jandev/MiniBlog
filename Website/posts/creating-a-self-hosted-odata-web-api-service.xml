<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>Creating a self-hosted OData Web API service</title>
  <slug>creating-a-self-hosted-odata-web-api-service</slug>
  <author>Jan</author>
  <pubDate>2013-08-23 20:04:07</pubDate>
  <lastModified>2014-04-25 12:06:07</lastModified>
  <content>&lt;p&gt;&lt;a href="http://blogs.msdn.com/b/henrikn/archive/2012/08/15/asp-net-web-api-released-and-a-preview-of-what-s-next.aspx"&gt;Some time ago&lt;/a&gt; Microsoft has introduced the ASP.NET Web API framework. It’s a framework you can use to create your own &lt;a href="http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_APIs"&gt;RESTful services&lt;/a&gt;. It’s much like &lt;a href="http://msdn.microsoft.com/en-us/data/odata.aspx"&gt;WCF Data Services&lt;/a&gt; or &lt;a href="http://msdn.microsoft.com/en-us/library/ee707344(v=vs.91).aspx"&gt;WCF RIA Services&lt;/a&gt;, but a lot easier to use (IMO). I’ve never liked the WCF-stack much, probably because configuring it always posed to be a hassle.&lt;/p&gt; &lt;p&gt;Using the Web API framework is much easier and you have to configure a lot less, or at least I haven’t found all of the configurable options yet. Then again, it’s created for entirely different purposes of course. &lt;br&gt;To create a service you &lt;a href="http://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api"&gt;select the ASP.NET MVC4 project template and can create new controllers which inherit from the ApiController&lt;/a&gt;. It’s also possible to do some awesome queries on your client nowadays, because Web API is capable of supporting &lt;a href="http://www.odata.org/"&gt;OData&lt;/a&gt;! Install the latest stable &lt;a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.OData/4.0.30506"&gt;NuGet package&lt;/a&gt; and you are ready to go!&lt;/p&gt; &lt;p&gt;Because I was put on a new project, I was finally able to do some real work with ASP.NET Web API. We had to develop a solution containing a so called self-hosted Web API service which also supported OData queries. This sounds like a lot of work, but it’s actually rather easy to do so nowadays. &lt;/p&gt; &lt;p&gt;During this new project we had some time to investigate and learn a bit about the platform. Therefore we chose to use the latest version of everything we could find, just to keep us up-to-date. To get OData working we used the &lt;a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.OData/5.0.0-beta2"&gt;beta2 version&lt;/a&gt; which works great for the simple stuff we were doing.&lt;br&gt;Now, all you have to do to get OData working is return &lt;em&gt;IQueryable&amp;lt;T&amp;gt;&lt;/em&gt; from your controller actions. For example:&lt;/p&gt;&lt;pre class="brush:csharp"&gt;[Queryable]
public IQueryable&lt;functionalevent&gt; GetEverything()
{
    using (var ctx = new HMOEvents("TheRepositoryConnectionStringName"))
    {
		return ctx.TableContainingEverything.OrderByDescending(e =&amp;gt; e.TimeCreated).ToList().AsQueryable();
    }
}&lt;/pre&gt;
&lt;p&gt;Hit F5 and you are ready to do some OData queries on this action. Awesome, huh?&lt;/p&gt;
&lt;p&gt;After we had figured this out, we still had to make this Web API service self-hosted. The reason for this requirement was because the webserver wasn’t in our control and the administrators had the tendency of resetting IIS quite a lot of times during the day (don’t ask….). I was already pulling my hair on figuring out how we had to do this, but as it turns out this is quite easy to do also.&lt;/p&gt;
&lt;p&gt;There’s a reference you can add called &lt;em&gt;System.Web.Http.SelfHost&lt;/em&gt;. You just have to create a new Console Application, add the reference and paste this piece of code over your Main method&lt;/p&gt;&lt;pre class="brush:csharp"&gt;static void Main(string[] args)
{
    HttpSelfHostServer server = null;
    try
    {
        // Set up server configuration 
	var config = new HttpSelfHostConfiguration(new Uri("http://localhost:2132"));
        config.EnableQuerySupport();
	config.Formatters.JsonFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue("application/json"));
	config.Routes.MapHttpRoute(
				name: "ActionApi",
				routeTemplate: "api/{controller}/{action}",
				defaults: new { action = "Get" }
	);
	config.Routes.MapHttpRoute(
		            name: "DefaultApi",
		            routeTemplate: "api/{controller}/{id}",
       			    defaults: new { id = RouteParameter.Optional }
        );

	config.EnableCors(new EnableCorsAttribute("*", "*", "*"));
	config.ReceiveTimeout = new TimeSpan(0, 0, 3, 0);
	config.SendTimeout = new TimeSpan(0, 0, 3, 0);
	// Create server 
	server = new HttpSelfHostServer(config);

        // Start listening 
        server.OpenAsync().Wait();
        Console.WriteLine("Listening on http://localhost:2132");
        Console.ReadLine();
    }
    catch (Exception e)
    {
        Console.WriteLine("Could not start server: {0}", e.GetBaseException().Message);
        Console.WriteLine("Hit ENTER to exit...");
        Console.ReadLine();
    }
    finally
    {
        if (server != null)
        {
            // Stop listening 
            server.CloseAsync().Wait();
        }
    } 
}
&lt;/pre&gt;
&lt;p&gt;After doing so you can add your Web API controllers to this Console Application and start the application. Once the application is started you are able to do your queries on http://localhost:2132. &lt;br&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;: You might need to check the firewall and run this application as an Administrator, otherwise it might cause some problems. Something about Windows security and setting up new ‘webservers’. It’s possible to do this without Administrator priviliges, to do this is &lt;/em&gt;&lt;a href="http://stackoverflow.com/a/17260905/352640"&gt;&lt;em&gt;explained on Stack Overflow&lt;/em&gt;&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Again, pretty awesome, huh? This saves up a lot of development time!&lt;/p&gt;
&lt;p&gt;You might have noticed I’ve used the following line to enable &lt;a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing"&gt;CORS&lt;/a&gt; on the service:&lt;/p&gt;&lt;pre&gt;config.EnableCors(new EnableCorsAttribute("*", "*", "*"));
&lt;/pre&gt;
&lt;p&gt;This isn’t some extension method and class that I’ve written myself. There’s something called &lt;a href="http://www.nuget.org/packages/Microsoft.AspNet.WebApi.Cors/5.0.0-beta2"&gt;Microsoft.AspNet.WebApi.Cors&lt;/a&gt; which is a NuGet package you can implement. At the time of the project, beta2 was the most recent version of these bits. Once you’ve included this in your project, you are able to enable CORS with just this extra line in the configuration. &lt;br&gt;For self-hosted services you have use this, because it’s rather hard (impossible?) to add the ‘&lt;em&gt;Acces-Control-Allow-Origin&lt;/em&gt;’ headers.&lt;/p&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>