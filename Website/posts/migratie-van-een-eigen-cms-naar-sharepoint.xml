<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>Migratie van een eigen CMS naar Sharepoint</title>
  <slug>migratie-van-een-eigen-cms-naar-sharepoint</slug>
  <author>Jan</author>
  <pubDate>2008-05-17 17:33:00</pubDate>
  <lastModified>2014-04-25 12:06:08</lastModified>
  <content>&lt;div class="ExternalClass7E68B7A8C27E466F85CC9B9EFEDC31CB"&gt;Tijdens het surfen en lezen van RSS posts kwam ik een interessant artikel tegen over het migreren van data tussen een eigen (third-party) CMS naar Sharepoint. Blijkbaar hoeft dit helemaal niet zo moeilijk te zijn, zo laat Pranab Paul zien. Je kunt gewoon een web part maken met een knop en daar de migratie code onder plaatsen. Het code snippet hieronder is een ordinaire copy-paste van Pranab Paul z'n weblog, dat hij hier heeft gepost: http://blogs.msdn.com/pranab/archive/2008/05/20/moss-2007-migrating-content-from-3rd-party-content-management-solution-to-moss-publishing-collaboration-portal.aspx&lt;/div&gt;
&lt;div class="ExternalClass7E68B7A8C27E466F85CC9B9EFEDC31CB"&gt;&lt;/div&gt;
&lt;div class="ExternalClass7E68B7A8C27E466F85CC9B9EFEDC31CB"&gt;
&lt;div class="code"&gt;using System; using System.Runtime.InteropServices; using System.Web.UI; using System.Web.UI.WebControls; using System.Web.UI.WebControls.WebParts; using System.Xml.Serialization; using Microsoft.SharePoint; using Microsoft.SharePoint.WebControls; using Microsoft.SharePoint.WebPartPages; using Microsoft.SharePoint.Publishing; using System.Data; using System.Data.SqlClient; namespace WPContentCreator { [Guid("b771c700-889b-4cc1-bd36-fe4abac02183")] public class WPContentCreator : System.Web.UI.WebControls.WebParts.WebPart { Button myBtn; string SqlQuery = "Select contentid,title,contentbody,contentdate,author from dbo.ContentTable"; public WPContentCreator() { } protected override void CreateChildControls() { myBtn = new Button(); myBtn.Text = "Submit"; myBtn.Click += new EventHandler(myBtn_Click); Controls.Add(myBtn); } protected override void Render(HtmlTextWriter writer) { myBtn.RenderControl(writer); } void myBtn_Click(object sender, EventArgs e) { SPSite site = SPContext.Current.Site; SPWeb web = site.OpenWeb(); PublishingSite publishingSite = new PublishingSite(site); PublishingWeb publishingWeb = PublishingWeb.GetPublishingWeb(web); SPContentTypeId articleContentTypeID = new SPContentTypeId("0x010100C568DB52D9D0A14D9B2FDCC96666E9F2007948130EC3DB064584E219954237AF3900242457EFB8B24247815D688C526CD44D0091053586ECA36C43BD6FD6B1B28A2071"); PageLayout[] layouts = publishingWeb.GetAvailablePageLayouts(articleContentTypeID); PageLayout articlePageLayout = layouts[0]; SqlConnection newSqlConnection = new SqlConnection(); SqlCommand newSqlCommand = new SqlCommand(this.SqlQuery, newSqlConnection); newSqlCommand.CommandType = System.Data.CommandType.Text; newSqlConnection.ConnectionString = "Integrated Security=True; Initial Catalog=test;Data Source=pranab-sec"; newSqlConnection.Open(); IDataReader rdr = newSqlCommand.ExecuteReader(); bool more; int results = 0; do { results++; while(rdr.Read()) { string pageName = rdr[0].ToString(); PublishingPage newPage = publishingWeb.GetPublishingPages().Add(string.Format("{0}_article_{1}.aspx", pageName, results), articlePageLayout); newPage.Title = rdr[1].ToString(); newPage.ListItem["Page Content"] = rdr[2].ToString(); newPage.ListItem["Article Date"] = DateTime.Parse(rdr[3].ToString()); newPage.ListItem["Byline"] = rdr[4].ToString(); newPage.Update(); newPage.CheckIn(""); } more = rdr.NextResult(); } while(more); newSqlConnection.Close(); } } }&lt;/div&gt;
&lt;div class="code"&gt;&lt;/div&gt;
Ja, de opmaak van mijn code is niet zo mooi als die van hem, maar het idee mag duidelijk zijn. Toch handig, want ik denk dat het steeds vaker voor zal komen dat Sharepoint een reeds bestaande omgeving moet gaan vervangen.&lt;/div&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>