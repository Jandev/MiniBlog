<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>Update: automatische URL herkenning</title>
  <slug>update-automatische-url-herkenning</slug>
  <author>Jan</author>
  <pubDate>2007-08-19 17:05:00</pubDate>
  <lastModified>2014-04-25 12:06:08</lastModified>
  <content>&lt;div class="ExternalClassDC53E1398FA24C7EAC8AC7FAB529BF64"&gt;Zo, vandaag heb ik even zitten ontwikkelen aan de website.&lt;br /&gt;De hele middag zijn er foutmeldingen getoond op de website, omdat ik lekker aan het prutsen was. Uiteraard zou ik ook lokaal PHP en MySQL kunnen installeren, maar dat doe ik liever niet. Lokaal houdt ik het maar bij ASP.Net.&lt;br /&gt;&lt;br /&gt;Een van de updates is, is dat de Google Ads nu beter in de stijl van de website vallen. Dit was even puzzelen, maar is toch goed gelukt naar mijn mening.&lt;br /&gt;&lt;br /&gt;De belangrijkste, en moeilijkste, update was om de automatische URL-herkenning werkend te krijgen.&lt;br /&gt;Dit kan met reguliere expressies, maar ik kon niet echt een goed werkende bedenken/vinden.&lt;br /&gt;Uiteindelijk heb ik met m'n eigen fantasie en hulp van de immens nuttige website http://www.regexlib.com/ toch een werkende reguliere expressie kunnen fabriceren.&lt;br /&gt;Hij ziet er zo uit:&lt;br /&gt;\\s((www|http|ftp)(\\W+\\S+[^).,:;?\\]\\} \\r\\n$]+))&lt;br /&gt;&lt;br /&gt;In PHP kun je dan met de functie preg_replace de reguliere expressie zo gebruiken.&lt;br /&gt;&lt;br /&gt;
&lt;div class="code"&gt;$pattern1 = "/\\s((www|http|ftp)(\\W+\\S+[^).,:;?\\]\\} \\r\\n$]+))/";&lt;br /&gt;$pattern2 = " &lt;a&gt;$1&lt;/a&gt;"; &lt;br /&gt;$text = preg_replace($pattern1, $pattern2, $text);&lt;/div&gt;
&lt;br /&gt;&lt;br /&gt;Gelukkig kon ik het testen in de maand augustus, aangezien ik daar enkele posts had met hyperlinks er in verstopt.&lt;br /&gt;&lt;br /&gt;Ook heb ik een reguliere expressie geimplementeerd die e-mail adressen kan parsen.&lt;br /&gt;Deze heb ik zelf niet bedacht, maar zo gevonden&lt;br /&gt;Hij wordt zo gebruikt in m'n pagina:&lt;br /&gt;
&lt;div class="code"&gt;&lt;br /&gt;$text = preg_replace("#(\\s)([a-z0-9\\-_.]+)@([^,&amp;lt; \\n\\r]+)#i", "$1&lt;a&gt;$2@$3&lt;/a&gt;", $text);&lt;/div&gt;
&lt;br /&gt;&lt;br /&gt;Deze functionaliteit vind ik wel enorm gaaf.&lt;br /&gt;&lt;br /&gt;Ook een functie geimplementeerd die de URL's kan afkappen wanneer ze te groot worden. Deze heb ik in een script gevonden tijdens m'n zoektocht op het internet vandaag.&lt;br /&gt;Wel een enorm handige functie, want anders vernaggelen de hyperlinks zo nu en dan de lay-out.&lt;br /&gt;
&lt;div class="code"&gt;&lt;br /&gt;function chunk_url(&amp;amp;$ret)&lt;br /&gt;{&lt;br /&gt;$links = explode(' $countlinks = count($links);&lt;br /&gt;for ($i = 0; $i &amp;lt; $countlinks; $i++)&lt;br /&gt;{&lt;br /&gt;$link = $links[$i];&lt;br /&gt;$link = (preg_match('#(.*)(href=")#is', $link)) ? '&lt;br /&gt;$begin = strpos($link, '&amp;gt;') + 1;&lt;br /&gt;$end = strpos($link, '&amp;lt;', $begin);&lt;br /&gt;$length = $end - $begin;&lt;br /&gt;$urlname = substr($link, $begin, $length);&lt;br /&gt;/**&lt;br /&gt;* We chunk urls that are longer than 50 characters. Just change&lt;br /&gt;* '50' to a value that suits your taste. We are not chunking the link&lt;br /&gt;* text unless if begins with 'http://', 'ftp://', or 'www.'&lt;br /&gt;*/&lt;br /&gt;$chunked = (strlen($urlname) &amp;gt; 50 &amp;amp;&amp;amp; preg_match('#^(http://|ftp://|www\\.)#is', $urlname)) ? substr_replace($urlname, '.....', 30, -10) : $urlname;&lt;br /&gt;$ret = str_replace('&amp;gt;' . $urlname . '&amp;lt;', '&amp;gt;' . $chunked . '&amp;lt;', $ret); &lt;br /&gt;}&lt;br /&gt;}&lt;/div&gt;
&lt;br /&gt;De disclaimer voor de functie:&lt;br /&gt;
&lt;div class="code"&gt;&lt;br /&gt;### Plugin Name: Chunk URLS for WordPress&lt;br /&gt;### Plugin URI: http://www.village-idiot.org/archives/2006/06/29/wp-chunk/&lt;br /&gt;### Description: Shortens URLs within comments so they don't break your site.&lt;br /&gt;### Author: whoo&lt;br /&gt;### Version: 2.0&lt;br /&gt;### Author URI: http://www.village-idiot.org/&lt;/div&gt;
&lt;br /&gt;&lt;br /&gt;Zo, nu is dat ook weer legaal.&lt;/div&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>