<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>Creating a Web API to work with XML requests</title>
  <slug>creating-a-web-api-to-work-with-xml-requests</slug>
  <author>Jan</author>
  <pubDate>2013-11-22 16:06:33</pubDate>
  <lastModified>2014-04-25 12:06:07</lastModified>
  <content>&lt;p&gt;For a project on the side I’m creating a Web API which has to parse XML requests in a POST. The first method I’ve written looks like this:&lt;/p&gt;&lt;pre class="brush:csharp"&gt;[HttpPost]
public HttpResponseMessage IndexPost(RequestModel requestMessage)
{
	return new HttpResponseMessage(HttpStatusCode.Accepted) { Content = new StringContent("This is the POST API response from BusinessPartner!") };
}
&lt;/pre&gt;
&lt;p&gt;To test the new API I’m using the &lt;a href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm" target="_blank"&gt;Postman Chrome plugin&lt;/a&gt;. With this plugin you are able to send requests to an endpoint and see what the response is. Of course you can also use &lt;a href="http://fiddler2.com/" target="_blank"&gt;Fiddler&lt;/a&gt; for this, but I like the user experience of Postman a bit more.&lt;/p&gt;
&lt;p&gt;There were a few problems I encountered during the development of the Web API. &lt;/p&gt;
&lt;p&gt;The first problem was this error:&lt;/p&gt;&lt;pre class="brush:csharp"&gt;{
    "message": "An error has occurred.",
    "exceptionMessage": "No MediaTypeFormatter is available to read an object of type 'RequestModel' from content with media type 'text/plain'.",
    "exceptionType": "System.InvalidOperationException",
    "stackTrace": "   at System.Net.Http.HttpContentExtensions.ReadAsAsync[T](HttpContent content, Type type, IEnumerable`1 formatters, IFormatterLogger formatterLogger)\r\n   at System.Net.Http.HttpContentExtensions.ReadAsAsync(HttpContent content, Type type, IEnumerable`1 formatters, IFormatterLogger formatterLogger)\r\n   at System.Web.Http.ModelBinding.FormatterParameterBinding.ReadContentAsync(HttpRequestMessage request, Type type, IEnumerable`1 formatters, IFormatterLogger formatterLogger)\r\n   at System.Web.Http.ModelBinding.FormatterParameterBinding.ExecuteBindingAsync(ModelMetadataProvider metadataProvider, HttpActionContext actionContext, CancellationToken cancellationToken)\r\n   at System.Web.Http.Tracing.Tracers.FormatterParameterBindingTracer.&amp;lt;&amp;gt;c__DisplayClass3.&lt;executebindingasync&gt;b__1()\r\n   at System.Web.Http.Tracing.ITraceWriterExtensions.TraceBeginEndAsync(ITraceWriter traceWriter, HttpRequestMessage request, String category, TraceLevel level, String operatorName, String operationName, Action`1 beginTrace, Func`1 execute, Action`1 endTrace, Action`1 errorTrace)\r\n   at System.Web.Http.Tracing.Tracers.FormatterParameterBindingTracer.ExecuteBindingAsync(ModelMetadataProvider metadataProvider, HttpActionContext actionContext, CancellationToken cancellationToken)\r\n   at System.Web.Http.Controllers.HttpActionBinding.&amp;lt;&amp;gt;c__DisplayClass1.&lt;executebindingasync&gt;b__0(HttpParameterBinding parameterBinder)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Threading.Tasks.TaskHelpers.IterateImpl(IEnumerator`1 enumerator, CancellationToken cancellationToken)"
}
&lt;/pre&gt;
&lt;p&gt;This was quite surprising as I thought I was sending a proper request which could be serialized. For reference, I was sending a POST request to &lt;a title="http://localhost:11210/api/businesspartnerapi/" href="http://localhost:11210/api/businesspartnerapi/"&gt;http://localhost:11210/api/businesspartnerapi/&lt;/a&gt; in this format:&lt;/p&gt;&lt;pre class="brush:xml"&gt;&amp;lt;RequestModel&amp;gt;&amp;lt;RequestMessage&amp;gt;1&amp;lt;/RequestMessage&amp;gt;&amp;lt;/RequestModel&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_2.png"&gt;&lt;img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_thumb.png" width="800" height="342"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As I couldn’t find anything on the internet explaining what I did wrong, I started looking through the options of Postman. Apparently you can add information to the header of the request, like a content type. After having added the contenttype &lt;em&gt;text/xml&lt;/em&gt; to the message the API returned the response which I had expected.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_6.png"&gt;&lt;img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_thumb_2.png" width="815" height="428"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Success!&lt;/p&gt;
&lt;p&gt;Apparently you need to specify the correct content type in order for ASP.NET to know how to deserialize the object.&lt;/p&gt;
&lt;p&gt;But there is more. The second problem I faced was the &lt;em&gt;requestMessage&lt;/em&gt; being &lt;em&gt;null&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_8.png"&gt;&lt;img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_thumb_3.png" width="1099" height="188"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Quite strange as the model is serializable. I’ve also added the [Serializable]-attribute to the model, but to no avail.&lt;/p&gt;
&lt;p&gt;From the back in the WCF days I remembered you have to add the [DataContract]- and [DataMember]-attributes to a model if you to use them in services. Therefore I added them to my model.&lt;/p&gt;
&lt;p&gt;The RequestModel now looks like this:&lt;/p&gt;&lt;pre class="brush:csharp"&gt;[DataContract(Namespace="")]
public class RequestModel
{
	[DataMember]
	public string RequestMessage { get; set; }
}
&lt;/pre&gt;
&lt;p&gt;After POST-ing another request to the API I was able to see the result.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_10.png"&gt;&lt;img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://jan-v.nl/Media/Default/Windows-Live-Writer/Creating-a-Web-API-to-work-with-XML-requ_E8CE/image_thumb_4.png" width="1163" height="320"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see in the Watch window, the object is successfully created with the value I expected.&lt;/p&gt;
&lt;p&gt;So, if you want to debug a Web API project, don’t forget to add the proper content type to your request and make sure you specify the attributes to your model so it can be (de)serialized.&lt;/p&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>