<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>Comparing varchar to nvarchar in SQL</title>
  <slug>comparing-varchar-to-nvarchar-in-sql</slug>
  <author>Jan</author>
  <pubDate>2012-11-05 20:34:39</pubDate>
  <lastModified>2014-04-25 12:06:07</lastModified>
  <content>&lt;p&gt;A few days ago I listened to a new episode of the &lt;a href="http://www.dotnetrocks.com/default.aspx?showNum=814"&gt;.NET Rocks podcast&lt;/a&gt;, with &lt;a href="https://twitter.com/KimberlyLTripp"&gt;Kimberly Tripp&lt;/a&gt; on the show. While she was going through the list of things every developer needs to know, one in particular caught my interest. She mentioned we should use the different types consistently in the database. Not using types consistently within your database can cause quite some performance loss. This is because SQL Server ‘upcasts’ the minor type to the higher type (example: &lt;em&gt;varchar&lt;/em&gt; to &lt;em&gt;nvarchar&lt;/em&gt;). As the term ‘&lt;em&gt;quite some performance loss&lt;/em&gt;’ is a bit broad, I wanted to know how much this performance loss is exactly and if it’s worth rewriting/redesigning your database.&lt;/p&gt; &lt;p&gt;To test this case I’ve created a small database, named &lt;em&gt;Performance&lt;/em&gt;, with a lot of records inside it. The database has 3 tables, named &lt;em&gt;AsciiTable&lt;/em&gt;, &lt;em&gt;MainTable&lt;/em&gt; and &lt;em&gt;UnicodeTable&lt;/em&gt;. All three of them contain 2 columns, ID and a text column. The &lt;em&gt;AsciiTable&lt;/em&gt;-table it’s text column has the type &lt;em&gt;varchar(30)&lt;/em&gt;, the &lt;em&gt;MainTable&lt;/em&gt; and &lt;em&gt;UnicodeTable&lt;/em&gt; it’s text column has the type &lt;em&gt;nvarchar(30)&lt;/em&gt;. I’ve created these to test how long some specific queries will take. At the end of this post I’ve inserted the script to create this database if you want to try it for yourself.&lt;/p&gt; &lt;p&gt;Most of the time doing queries on tables which are quite small, performance is fine. Therefore I decided I needed to fill up these three tables with a lot of data. Thankfully we live in 2012 and we developers can use all these fine features like LINQ2SQL and the Entity Framework nowadays. Therefore the code I needed to write to fill up the tables was fairly compact:&lt;/p&gt;&lt;pre class="brush: c-sharp; toolbar: false"&gt;public void InsertALotOfItemsInTheDatabase()
{
	var db = new PerformanceEntities();

	for (uint i = 0; i &amp;lt; uint.MaxValue; i++)
	{
		var textToInsert = string.Format("This is the {0} text!", i);
		db.AddToMainTables(new MainTable { Sometext = textToInsert });
		db.AddToAsciiTables(new AsciiTable { SomeAsciiText = textToInsert });
		db.AddToUnicodeTables(new UnicodeTable { SomeUnicodeText = textToInsert });

		if (i % 10 == 0)
		{
			db.SaveChanges();
		}
		Console.WriteLine(textToInsert);

	}
	db.SaveChanges();
}&lt;/pre&gt;
&lt;p&gt;You don’t really need the &lt;em&gt;Console.WriteLine&lt;/em&gt; in the middle of the &lt;em&gt;for&lt;/em&gt;-loop, but I like to have some response on the command line to see if everything is still working. After running this code for a few hours I was prompted with an &lt;a href="http://msdn.microsoft.com/en-us/library/system.outofmemoryexception.aspx"&gt;OutOfMemoryException&lt;/a&gt;, so this code probably needs some fine-tuning and connection closing. Because there were 1.999.838 items in each table now I was satisfied for now. I’d like to have more, but having about 2 million items in the tables should do the trick also. Also, inserting a lot of items sure takes a lot of time and I wanted to start testing already.&lt;/p&gt;
&lt;p&gt;Having the tables filled up I’ve written some tests to see if performance would be affected when comparing Unicode and ASCII strings with each other.&lt;/p&gt;
&lt;p&gt;The first tests I’ve created was using a LIKE in the WHERE-clause and using ASCII and Unicode strings on the different columns. The methods look like this:&lt;/p&gt;&lt;pre class="brush: c-sharp; toolbar: false"&gt;public void TestThePerformanceOfQueries()
{
	const int MAX_NUMBER_OF_LOOPS = 30;
	const string connectionString = "Server=localhost;Database=Performance;Trusted_Connection=True;";
	using (var connection = new SqlConnection(connectionString))
	{
		connection.Open();
		var stopWatch = new Stopwatch();

		stopWatch.Start();
		for (int i = 0; i &amp;lt; MAX_NUMBER_OF_LOOPS; i++)
		{
			QueryUnicodeTableWithUnicodeWhereClause(connection, i);
		}
		stopWatch.Stop();
		Console.WriteLine(string.Format("The QueryUnicodeTableWithUnicodeWhereClause queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
		stopWatch.Reset();

		stopWatch.Start();
		for (int j = 0; j &amp;lt; MAX_NUMBER_OF_LOOPS; j++)
		{
			QueryUnicodeTableWithAsciiWhereClause(connection, j);
		}
		stopWatch.Stop();
		Console.WriteLine(string.Format("The QueryUnicodeTableWithAsciiWhereClause queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
		stopWatch.Reset();

		stopWatch.Start();
		for (int k = 0; k &amp;lt; MAX_NUMBER_OF_LOOPS; k++)
		{
			QueryAsciiTableWithAsciiWhereClause(connection, k);
		}
		Console.WriteLine(string.Format("The QueryAsciiTableWithAsciiWhereClause queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
		stopWatch.Reset();

		stopWatch.Start();
		for (int l = 0; l &amp;lt; MAX_NUMBER_OF_LOOPS; l++)
		{
			QueryAsciiTableWithUnicodeWhereClause(connection, l);
		}
		stopWatch.Stop();
		Console.WriteLine(string.Format("The QueryAsciiTableWithUnicodeWhereClause queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
		stopWatch.Reset();
	}
}

private void QueryUnicodeTableWithUnicodeWhereClause(SqlConnection connection, int id)
{
	string query = string.Format(@"SELECT [ID] ,[SomeUnicodeText] 
									FROM [Performance].[dbo].[UnicodeTable] 
									WHERE [SomeUnicodeText] LIKE N'%{0}%'", id);
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}

private void QueryUnicodeTableWithAsciiWhereClause(SqlConnection connection, int id)
{
	string query = string.Format(@"SELECT [ID] ,[SomeUnicodeText] 
									FROM [Performance].[dbo].[UnicodeTable] 
									WHERE [SomeUnicodeText] LIKE '%{0}%'", id);
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}

private void QueryAsciiTableWithAsciiWhereClause(SqlConnection connection, int id)
{
	string query = string.Format(@"SELECT [ID] ,[SomeAsciiText] 
									FROM [Performance].[dbo].[AsciiTable] 
									WHERE [SomeAsciiText] LIKE '%{0}%'", id);
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}

private void QueryAsciiTableWithUnicodeWhereClause(SqlConnection connection, int id)
{
	string query = string.Format(@"SELECT [ID] ,[SomeAsciiText] 
									FROM [Performance].[dbo].[AsciiTable] 
									WHERE [SomeAsciiText] LIKE N'%{0}%'", id);
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}

}&lt;/pre&gt;
&lt;p&gt;The results of these queries aren’t that exciting. All tests take about the same time to execute:&lt;/p&gt;&lt;pre class="brush: shell; toolbar: false"&gt;The QueryUnicodeTableWithUnicodeWhereClause queries have taken 35210 milliseconds!
The QueryUnicodeTableWithAsciiWhereClause queries have taken 34335 milliseconds!
The QueryAsciiTableWithAsciiWhereClause queries have taken 32946 milliseconds!
The QueryAsciiTableWithUnicodeWhereClause queries have taken 33810 milliseconds!
&lt;/pre&gt;
&lt;p&gt;It appears it doesn’t matter (much) what type of string you are using in the WHERE-clause of a SQL-query. &lt;/p&gt;
&lt;p&gt;I wasn’t satisfied with these results as it’s unlikely Kimberly was wrong on the podcast, so I’ve created a few other test methods. In these new methods the columns are compared with each other in SQL and not with a string supplied in C#. These new methods look like below:&lt;/p&gt;&lt;pre class="brush: c-sharp; toolbar: false"&gt;private void QueryUnicodeTableInnerJoinAsciiTableWithWhereOnId(SqlConnection connection)
{
	string query = string.Format(@"SELECT TOP 10000 *
									FROM [UnicodeTable] INNER JOIN [AsciiTable]
										ON [UnicodeTable].[ID] = [AsciiTable].[ID]
									WHERE [UnicodeTable].[SomeUnicodeText] = [AsciiTable].[SomeAsciiText]");
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}

private void QueryUnicodeTableInnerJoinMainTableWithWhereOnId(SqlConnection connection)
{
	string query = string.Format(@"SELECT TOP 10000 *
									FROM [UnicodeTable] INNER JOIN [MainTable]
										ON [UnicodeTable].[ID] = [MainTable].[ID]
									WHERE [UnicodeTable].[SomeUnicodeText] = [MainTable].[SomeText]");
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}

private void QueryMainTableInnerJoinAsciiTableWithWhereOnId(SqlConnection connection)
{
	string query = string.Format(@"SELECT TOP 10000 *
									FROM [MainTable] INNER JOIN [AsciiTable]
										ON [MainTable].[ID] = [AsciiTable].[ID]
									WHERE [MainTable].[SomeText] = [AsciiTable].[SomeAsciiText]");
	var command = new SqlCommand(query, connection);
	using (var dataReader = command.ExecuteReader())
	{
		if (dataReader != null)
		{
			var result = dataReader.Read();
		}
	}
}&lt;/pre&gt;
&lt;p&gt;And they are called the same way as before:&lt;/p&gt;&lt;pre class="brush: c-sharp; toolbar: false"&gt;stopWatch.Start();
for (int m = 0; m &amp;lt; MAX_NUMBER_OF_LOOPS; m++)
{
	QueryUnicodeTableInnerJoinAsciiTableWithWhereOnId(connection);
}
stopWatch.Stop();
Console.WriteLine(string.Format("The QueryUnicodeTableInnerJoinAsciiTableWithWhereOnId queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
stopWatch.Reset();

stopWatch.Start();
for (int n = 0; n &amp;lt; MAX_NUMBER_OF_LOOPS; n++)
{
	QueryUnicodeTableInnerJoinMainTableWithWhereOnId(connection);
}
stopWatch.Stop();
Console.WriteLine(string.Format("The QueryUnicodeTableInnerJoinMainTableWithWhereOnId queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));
stopWatch.Reset();

stopWatch.Start();
for (int n = 0; n &amp;lt; MAX_NUMBER_OF_LOOPS; n++)
{
	QueryMainTableInnerJoinAsciiTableWithWhereOnId(connection);
}
stopWatch.Stop();
Console.WriteLine(string.Format("The QueryMainTableInnerJoinAsciiTableWithWhereOnId queries have taken {0} milliseconds!", stopWatch.ElapsedMilliseconds));&lt;/pre&gt;
&lt;p&gt;Results of these tests are stunning!&lt;/p&gt;&lt;pre class="brush: shell; toolbar: false"&gt;The QueryUnicodeTableInnerJoinAsciiTableWithWhereOnId queries have taken 23997 milliseconds!
The QueryUnicodeTableInnerJoinMainTableWithWhereOnId queries have taken 312 milliseconds!
The QueryMainTableInnerJoinAsciiTableWithWhereOnId queries have taken 24119 milliseconds!
&lt;/pre&gt;
&lt;p&gt;Comparing columns in SQL which are of a different type really causes a big performance loss. As you can see, comparing a nvarchar with an other nvarchar column only takes 312 milliseconds in the scenario we tested. When comparing a varchar with a nvarchar, it takes about 23 seconds. So comparing columns of the same type is 100 times faster (in above scenario)!&lt;/p&gt;
&lt;p&gt;I was really shocked when seeing these results and it shows we should design databases with care and consistency, as Kimberly already suggested. So, to everyone who is reading this post, check your databases for inconsistency and try to fix it.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Database script to create the database:&lt;/p&gt;&lt;pre class="brush: sql; collapse: true"&gt;USE [Performance]
GO
/****** Object:  Table [dbo].[UnicodeTable]    Script Date: 11/05/2012 20:34:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[UnicodeTable](
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[SomeUnicodeText] [nvarchar](30) NULL,
 CONSTRAINT [PK_UnicodeTable] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MainTable]    Script Date: 11/05/2012 20:34:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MainTable](
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[Sometext] [nvarchar](30) NULL,
 CONSTRAINT [PK_MainTable] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[AsciiTable]    Script Date: 11/05/2012 20:34:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[AsciiTable](
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[SomeAsciiText] [varchar](30) NULL,
 CONSTRAINT [PK_AsciiTable] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
&lt;/pre&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>