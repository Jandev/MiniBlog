<?xml version="1.0" encoding="utf-8"?>
<post>
  <title>N-tier en LINQ to SQL</title>
  <slug>n-tier-en-linq-to-sql</slug>
  <author>Jan</author>
  <pubDate>2008-01-08 21:35:00</pubDate>
  <lastModified>2014-04-25 12:06:08</lastModified>
  <content>&lt;div class="ExternalClass833E346F3F10404DAA881F21EBFEA036"&gt;Zo, ik heb het voor elkaar.&lt;br /&gt;Met de methode hoe ik nu LINQ to SQL heb toegepast in m'n solution kan ik toch de aloude n-tier architectuur blijven behouden.&lt;br /&gt;&lt;br /&gt;Om dit te bewerkstelligen moet je jammergenoeg wel afstappen van de eenvoudige grafische user interface die Visual Studio 2008 aanbied. Je moet nu namelijk van de console applicatie SQLMetal.exe gebruik maken.&lt;br /&gt;Ook wel te doen natuurlijk, maar het is een beetje jammer dat dit niet standaard in VS.Net 2008 kan.&lt;br /&gt;&lt;br /&gt;Eerst heb ik vandaag enkele posts van Scott Guthrie doorgelezen.&lt;br /&gt;De belangrijksten waren deze wel.&lt;br /&gt;&lt;em&gt;Using LINQ to SQL (Part 1)&lt;/em&gt;&lt;br /&gt;http://weblogs.asp.net/scottgu/archive/2007/05/19/using-linq-to-sql-part-1.aspx&lt;br /&gt;&lt;br /&gt;&lt;em&gt;LINQ to SQL (Part 2 - Defining our Data Model&lt;/em&gt; Classes) &lt;br /&gt;http://weblogs.asp.net/scottgu/archive/2007/05/29/linq-to-sql-part-2-defining-our-data-model-classes.aspx&lt;br /&gt;&lt;br /&gt;&lt;em&gt;LINQ to SQL (Part 3 - Querying our Database)&lt;/em&gt;&lt;br /&gt;http://weblogs.asp.net/scottgu/archive/2007/06/29/linq-to-sql-part-3-querying-our-database.aspx&lt;br /&gt;&lt;br /&gt;&lt;em&gt;LINQ to SQL (Part 4 - Updating our Database)&lt;/em&gt;&lt;br /&gt;http://weblogs.asp.net/scottgu/archive/2007/07/11/linq-to-sql-part-4-updating-our-database.aspx&lt;br /&gt;&lt;br /&gt;In een van deze posts stond een linkje naar een video post van Mike Taulty. Op zijn weblog heb ik het volgende filmpje bekeken:&lt;br /&gt;http://mtaulty.com/videos/nuggets/l2s/04_mt_l2s_codegentools.wmv&lt;br /&gt;&lt;br /&gt;Dit is een enorm informatief stukje over LINQ to SQL.&lt;br /&gt;Wanneer je dit filmpje hebt gezien kun je met een beetje fantasie wel begrijpen hoe je nu een n-tier architectuur kunt toepassen.&lt;br /&gt;&lt;br /&gt;Ten eerste maak je de mapping XML en mapping CS bestanden aan. &lt;br /&gt;Zelf heb ik dit gedaan door de volgende command-line te gebruiken in de Visual Studio 2008 Command Prompt in te tikken:&lt;br /&gt;
&lt;div class="code"&gt;&lt;br /&gt;sqlmetal.exe /server:. /database:Weblog /map:WeblogMapping.xml /pluralize /namespace:Weblog.Information&lt;/div&gt;
&lt;br /&gt;Nu worden je mapping bestanden aangemaakt.&lt;br /&gt;Deze zet je in een project waar je normaliter je information packages plaatst.&lt;br /&gt;Het verschil met vroeger is dat je nu 1 groot CS-bestand hebt met daarin alle packages. Het XML-bestand dient voor de daadwerkelijke mapping naar de database. Het CS-bestand is alleen nodig om de objecten bruikbaar te maken in je code.&lt;br /&gt;&lt;br /&gt;Nadat je dit hebt gedaan maak je vanuit je DataAccess laag een reference naar je project met de information packages.&lt;br /&gt;Nu kun je vanuit je DataAccess gebruik maken van de objecten die zijn gedefinieerd in je information packages project. Je zult dit project uiteraard ook moeten toevoegen aan de Business- en Presentatie-laag, maar dat deed je vroeger ook al. Het grote voordeel van deze methode is dat de mapping bestanden geen Select, Insert, Update en Delete functies bevatten. Al je lagen kunnen dus niet geen verbinding maken met de database. Dit is alleen weggelegd voor de DataAccess.&lt;br /&gt;&lt;br /&gt;Een stukje testcode dat ik nu in m'n DataAccess heb staan is dit:&lt;br /&gt;
&lt;div class="code"&gt;&lt;br /&gt;DataContext ctx = new DataContext("server=.;database=Weblog", XmlMappingSource.FromUrl( System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase) + @"\\WeblogMapping.xml"));&lt;br /&gt;Item item = new Item();&lt;br /&gt;&lt;br /&gt;var query = from c in ctx.GetTable() select c;&lt;br /&gt;&lt;br /&gt;foreach (Item c in query)&lt;br /&gt;{&lt;br /&gt;//Doe iets&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;return;&lt;/div&gt;
&lt;br /&gt;&lt;br /&gt;Deze code slaat natuurlijk nog nergens op. Het is dan ook een voorbeeld van hoe je gebruik moet maken van je objecten en hoe je L2SQL kunt gaan gebruiken.&lt;br /&gt;&lt;br /&gt;Het grootste nadeel is dat je nu niet meer een mooi dbml-bestand hebt en je niet meer via de grafische interface dingen kunt gaan doen.&lt;br /&gt;Ook is het zo dat wanneer er een database wijziging plaats vind je opnieuw het cs- en xml-bestand moet aanmaken. In deze bestanden moet je zelf dus &lt;strong&gt;niet&lt;/strong&gt; wijzigingen aanbrengen. Die gaan namelijk verloren zodra je opnieuw een mapping maakt. Dit is trouwens ook zo wanneer je wel gebruik maakt van de grafische interface.&lt;br /&gt;Tijdens het ontwikkelen van L2SQL zijn ze er waarschijnlijk vanuit gegaan dat tijdens het ontwikkel proces het database ontwerp al vast ligt en hier niets meer aan veranderd.&lt;br /&gt;&lt;br /&gt;Dat je geen wijzigingen kan/mag maken in de mapping bestanden is op zich niet er. Alle klassen zijn &lt;em&gt;partial&lt;/em&gt;, waardoor je gewoon in een ander bestand eventuele extra code kunt toevoegen. Dat is dan wel aardig van de L2SQL ontwikkelaars.&lt;br /&gt;&lt;br /&gt;PS: Denk er trouwens wel aan dat je het mapping xml-bestand altijd kopieert naar de output directory. Wanneer je dit niet doet, dan kun je geen gebruik maken van de functie &lt;em&gt;XmlMappingSource.FromUrl()&lt;/em&gt;, aangezien er geen XML-bestand is om vanaf te 'mappen'.&lt;/div&gt;</content>
  <ispublished>true</ispublished>
  <categories></categories>
  <comments></comments>
</post>